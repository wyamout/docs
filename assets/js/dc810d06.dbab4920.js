"use strict";(self.webpackChunklukso_docs=self.webpackChunklukso_docs||[]).push([[1634],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(t),h=r,m=d["".concat(s,".").concat(h)]||d[h]||p[h]||o;return t?a.createElement(m,i(i({ref:n},u),{},{components:t})):a.createElement(m,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7040:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=t(3117),r=(t(7294),t(3905));const o={title:"Multi-channel nonces",sidebar_position:1},i="Frequently Asked Questions",l={unversionedId:"standards/faq/channel-nonce",id:"standards/faq/channel-nonce",title:"Multi-channel nonces",description:"What are multi-channel nonces?",source:"@site/docs/standards/faq/channel-nonce.md",sourceDirName:"standards/faq",slug:"/standards/faq/channel-nonce",permalink:"/standards/faq/channel-nonce",draft:!1,editUrl:"https://github.com/lukso-network/docs/tree/main/docs/standards/faq/channel-nonce.md",tags:[],version:"current",lastUpdatedAt:1654869574,formattedLastUpdatedAt:"Jun 10, 2022",sidebarPosition:1,frontMatter:{title:"Multi-channel nonces",sidebar_position:1},sidebar:"standardsSidebar",previous:{title:"LSP1UniversalReceiverDelegateVault",permalink:"/standards/smart-contracts/lsp1-universal-receiver-delegate-vault"}},s={},c=[{value:"What are multi-channel nonces?",id:"what-are-multi-channel-nonces",level:2},{value:"Problem of Sequential Nonces.",id:"problem-of-sequential-nonces",level:3},{value:"Multi-Channel Nonces",id:"multi-channel-nonces",level:3},{value:"Nonces in the Key Manager",id:"nonces-in-the-key-manager",level:3},{value:"Solidity Code Example",id:"solidity-code-example",level:3}],u={toc:c};function p(e){let{components:n,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"frequently-asked-questions"},"Frequently Asked Questions"),(0,r.kt)("h2",{id:"what-are-multi-channel-nonces"},"What are multi-channel nonces?"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Developers took this concept from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/amxx/permit#out-of-order-execution"},"Out of order execution"),".")),(0,r.kt)("p",null,"Using nonces prevents old signed transactions from replaying again (replay attacks). A nonce is an arbitrary number that builders can use just once in a transaction."),(0,r.kt)("h3",{id:"problem-of-sequential-nonces"},"Problem of Sequential Nonces."),(0,r.kt)("p",null,"With native transactions, nonces are strictly sequential. Sequentialness means that message nonces must be executed in order. For instance, for message number 4 to be performed, it must wait for message number 3 to complete."),(0,r.kt)("p",null,"However, ",(0,r.kt)("strong",{parentName:"p"},"sequential nonces come with the following limitation"),":"),(0,r.kt)("p",null,"Some users may want to sign multiple messages, allowing the transfer of different assets to different recipients. In that case, the recipient wants to be able to use or transfer their assets whenever they want and will certainly not want to wait on anyone before signing another transaction."),(0,r.kt)("p",null,"When facing this problem, ",(0,r.kt)("strong",{parentName:"p"},"out-of-order execution")," comes in handy."),(0,r.kt)("h3",{id:"multi-channel-nonces"},"Multi-Channel Nonces"),(0,r.kt)("p",null,"Out-of-order execution is achieved by using multiple independent channels. Each channel's nonce behaves as expected, but different channels are independent. The subdivision means that messages 2, 3, and 4 of channel 0 must be executed sequentially, but message 3 of ",(0,r.kt)("inlineCode",{parentName:"p"},"channel 1")," is separate and only depends on message 2 of ",(0,r.kt)("inlineCode",{parentName:"p"},"channel 1"),"."),(0,r.kt)("p",null,"The benefit is that the signer key can determine which channel to sign the nonces. Relay services will have to understand the channel the signer chooses and execute each channel's transactions in the correct order to prevent failing transactions."),(0,r.kt)("h3",{id:"nonces-in-the-key-manager"},"Nonces in the Key Manager"),(0,r.kt)("p",null,"The Key Manager allows out-of-order execution of messages by using nonces through multiple channels."),(0,r.kt)("p",null,"Nonces are represented as ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," from the concatenation of two ",(0,r.kt)("inlineCode",{parentName:"p"},"uint128")," : the ",(0,r.kt)("inlineCode",{parentName:"p"},"channelId")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"nonceId"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"left most 128 bits : ",(0,r.kt)("inlineCode",{parentName:"li"},"channelId")),(0,r.kt)("li",{parentName:"ul"},"right most 128 bits: ",(0,r.kt)("inlineCode",{parentName:"li"},"nonceId"))),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"multi-channel-nonce",src:t(6485).Z,width:"1062",height:"207"})),(0,r.kt)("p",{align:"center"},(0,r.kt)("i",null,"Example of multi channel nonce, where channelId == 5 and nonceId == 1")),(0,r.kt)("p",null,"The current nonce can be queried using:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function getNonce(address _address, uint256 _channel) public view returns (uint256)\n")),(0,r.kt)("p",null,"Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"channelId")," represents the left-most 128 bits, a minimal value like ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," will return a huge ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," number: ",(0,r.kt)("inlineCode",{parentName:"p"},"2**128")," equal to:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"340282366920938463463374607431768211456"),"."),(0,r.kt)("p",null,"After the signed transaction is executed the ",(0,r.kt)("inlineCode",{parentName:"p"},"nonceId")," will be incremented by ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),", this will increment the ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce")," by ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," because the nonceId represents the first 128 bits of the nonce, so that it will be"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"340282366920938463463374607431768211457"),"."),(0,r.kt)("h3",{id:"solidity-code-example"},"Solidity Code Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"_nonces[signer][nonce >> 128]++\n")),(0,r.kt)("p",null,"The expression ",(0,r.kt)("inlineCode",{parentName:"p"},"nonce >> 128")," represents the channel which the signer chose for executing the transaction. After looking up the nonce of the signer at that specific channel, it will be incremented by one using ",(0,r.kt)("inlineCode",{parentName:"p"},"++"),"."),(0,r.kt)("p",null,"For sequential messages, users could use channel ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", and for out-of-order messages, they could use channel ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Important:")," It's up to the user to choose the channel that he wants to sign multiple sequential orders on, not necessary ",(0,r.kt)("inlineCode",{parentName:"p"},"channel 0"),"."))}p.isMDXComponent=!0},6485:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/multi-channel-nonce-8f6924f7e882d0499add36aedd6bc954.jpg"}}]);