"use strict";(self.webpackChunklukso_docs=self.webpackChunklukso_docs||[]).push([[9858],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=l(n),m=r,h=u["".concat(c,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1626:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_label:"LSP1 - Universal Receiver",sidebar_position:1},s="LSP1 - Universal Receiver",o={unversionedId:"standards/generic-standards/lsp1-universal-receiver",id:"standards/generic-standards/lsp1-universal-receiver",title:"LSP1 - Universal Receiver",description:"LSP1 - Universal Receiver",source:"@site/docs/standards/generic-standards/lsp1-universal-receiver.md",sourceDirName:"standards/generic-standards",slug:"/standards/generic-standards/lsp1-universal-receiver",permalink:"/standards/generic-standards/lsp1-universal-receiver",draft:!1,editUrl:"https://github.com/lukso-network/docs/tree/main/docs/standards/generic-standards/lsp1-universal-receiver.md",tags:[],version:"current",lastUpdatedAt:1665125948,formattedLastUpdatedAt:"Oct 7, 2022",sidebarPosition:1,frontMatter:{sidebar_label:"LSP1 - Universal Receiver",sidebar_position:1},sidebar:"standardsSidebar",previous:{title:"ERC725",permalink:"/standards/lsp-background/erc725"},next:{title:"LSP1 - Universal Receiver Delegate",permalink:"/standards/generic-standards/lsp1-universal-receiver-delegate"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"What does this standard represent?",id:"what-does-this-standard-represent",level:2},{value:"Specification",id:"specification",level:3},{value:"Extension",id:"extension",level:2},{value:"References",id:"references",level:2}],d={toc:l};function p(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lsp1---universal-receiver"},"LSP1 - Universal Receiver"),(0,r.kt)("admonition",{title:"Standard Document",type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-1-UniversalReceiver.md"},"LSP1 - Universal Receiver"))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"There is often the need for smart contracts to ",(0,r.kt)("strong",{parentName:"p"},"be aware of incoming transactions"),", especially receiving tokens."),(0,r.kt)("p",null,"A good example is ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://eips.ethereum.org/EIPS/eip-20"},"ERC20"))," token transfers. When a smart contract receives a token, it has no generic way ",(0,r.kt)("strong",{parentName:"p"},"to be notified")," about it. During the token transfer, the sender's balance decreases, and the recipient's balance increases. There are ",(0,r.kt)("strong",{parentName:"p"},"no further interactions"),", and the ERC20 token contract just acts as a registry."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Smart contract recipient outside interaction",src:n(2164).Z,width:"2668",height:"1499"})),(0,r.kt)("p",null,"One solution to this problem could be to listen to all the ERC20 token transfer events on the network. However, this requires using a trusted third party to listen to the events. Such a method limits smart contracts autonomy and introduces a single point of failure."),(0,r.kt)("p",null,"Standards like ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://eips.ethereum.org/EIPS/eip-223"},"ERC223")),", ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://eips.ethereum.org/EIPS/eip-712"},"ERC721")),", and ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://eips.ethereum.org/EIPS/eip-1155"},"ERC1155"))," require having specific functions in order to receive and be notified about the token such as ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenReceived(..)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"onERC721Received(..)"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"onERC1155Received(..)")," respectively."),(0,r.kt)("p",null,"These functions have different contexts, parameters, and events that make the smart contract not interoperable. If later in the future, a token standard ",(0,r.kt)("strong",{parentName:"p"},"ERCXXXX")," gets adopted, the smart contract (account, DEXs) will not be able to receive these kinds of tokens because it was already deployed on the network and ",(0,r.kt)("strong",{parentName:"p"},"does not support")," ",(0,r.kt)("inlineCode",{parentName:"p"},"onERCXXXXReceived(..)")," function."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"On token received functions",src:n(7018).Z,width:"3284",height:"1217"})),(0,r.kt)("p",null,"One way to solve this problem is by creating a ",(0,r.kt)("strong",{parentName:"p"},"standard and unified function")," that any smart contract can implement. DEXs, Wallets, or profiles could use this function to be notified about an incoming asset, information, followers, etc."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Unified notification function to call",src:n(7543).Z,width:"2456",height:"1628"})),(0,r.kt)("h2",{id:"what-does-this-standard-represent"},"What does this standard represent?"),(0,r.kt)("h3",{id:"specification"},"Specification"),(0,r.kt)("admonition",{title:"recommendation",type:"success"},(0,r.kt)("p",{parentName:"admonition"},"Smart contracts implementing the ",(0,r.kt)("a",{parentName:"p",href:"#"},"LSP1-UniversalReceiver")," standard SHOULD ",(0,r.kt)("strong",{parentName:"p"},"register")," the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/standards/smart-contracts/interface-ids"},"LSP1UniversalReceiver InterfaceId")," using ERC165"),". This way, other contracts can be aware that the contract supports the LSP1 standard.")),(0,r.kt)("p",null,"This standard defines a single function named ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(...)")," that could receive ",(0,r.kt)("strong",{parentName:"p"},"any arbitrary information"),". It takes two parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"bytes32 ",(0,r.kt)("inlineCode",{parentName:"li"},"typeId"),": Hash or Hook of a specific standard."),(0,r.kt)("li",{parentName:"ul"},"bytes ",(0,r.kt)("inlineCode",{parentName:"li"},"data"),": Any arbitrary data.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Receiving contracts should consider the ",(0,r.kt)("inlineCode",{parentName:"p"},"typeId")," parameter to ",(0,r.kt)("strong",{parentName:"p"},"decode the data correctly"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(...)")," function ",(0,r.kt)("strong",{parentName:"p"},"emits an event with the data passed to it and some additional data"),". "),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"universalReceiver function emits an event",src:n(5797).Z,width:"2564",height:"1559"})),(0,r.kt)("p",null,"For example, ",(0,r.kt)("strong",{parentName:"p"},"to notify the recipient that he is about to receive tokens"),", during a token transfer, the token contract can call the ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(..)")," function of the recipient with:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"bytes32 ",(0,r.kt)("inlineCode",{parentName:"li"},"typeId"),": ",(0,r.kt)("strong",{parentName:"li"},"Hash"),"('ERCXXXXTokenReceived')"),(0,r.kt)("li",{parentName:"ul"},"bytes ",(0,r.kt)("inlineCode",{parentName:"li"},"data"),": ",(0,r.kt)("strong",{parentName:"li"},"packedData"),"(amount of token sent, the sender address, the block timestamp)")),(0,r.kt)("p",null,"In this way, instead of ",(0,r.kt)("strong",{parentName:"p"},"listening to all the events of the token contrats on the network"),", and checking which one of these transfers is relative to the recipient, users can listen to the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/standards/smart-contracts/lsp0-erc725-account#universalreceiver-1"},"UniversalReceiver"))," event on the contract implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(..)")," and know the token transfer details.  "),(0,r.kt)("p",null,"As well as emitting an event, the ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(...)")," function can implement ",(0,r.kt)("strong",{parentName:"p"},"custom logic")," to make the contract behave differently based on the data received. Some ideas include:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Reverting on calls to completely disallow the smart contract from receiving assets, information, etc. \u274c"),(0,r.kt)("li",{parentName:"ul"},"Registering the received assets inside the contract storage (see ",(0,r.kt)("a",{parentName:"li",href:"/standards/universal-profile/lsp5-received-assets"},"LSP5 - Received Assets"),"). \u2795"),(0,r.kt)("li",{parentName:"ul"},"Disallowing receiving specific tokens from specific token contract addresses, for instance (e.g: spam tokens)."),(0,r.kt)("li",{parentName:"ul"},"Forwarding all the received assets to an external vault or a staking contract."),(0,r.kt)("li",{parentName:"ul"},"Forwarding specific tokens in a contract behind a protocol or dApp (e.g: liquidity or lending pool to earn interest)."),(0,r.kt)("li",{parentName:"ul"},"Depending on the typeId, save a percentage % of tokens received (native tokens or not), by placing them in a vault for instance.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"universalReceiver function execute custom logic",src:n(2807).Z,width:"2560",height:"1562"})),(0,r.kt)("h2",{id:"extension"},"Extension"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"See the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/standards/generic-standards/lsp1-universal-receiver-delegate"},"LSP1-UniversalReceiverDelegate"))," standard for more details.")),(0,r.kt)("p",null,"Overriding and customizing the ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(..)")," function is an option for users to allow ",(0,r.kt)("strong",{parentName:"p"},"different behaviours depending on the data received"),". However, it's not advised to hardcode the logic of reacting to specific actions inside the function because ",(0,r.kt)("strong",{parentName:"p"},"this logic may need to change in the future")," depending on several factors (eg. the vault where the tokens are forwarded gets compromised, a new staking contract is deployed, decided to revert on specific tokens later). "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/standards/generic-standards/lsp1-universal-receiver-delegate"},"LSP1-UniversalReceiverDelegate"))," is an ",(0,r.kt)("strong",{parentName:"p"},"optional extension")," to the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"#"},"LSP1-UniversalReceiver"))," standard. As well as notifying a contract about the incoming and outgoing transactions by emitting an event, it can delegate the call to an external contract that can ",(0,r.kt)("strong",{parentName:"p"},"handle and react to specific calls")," with its custom logic."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Universal Receiver Delegate contract",src:n(4709).Z,width:"2466",height:"1621"})),(0,r.kt)("p",null," address of the ",(0,r.kt)("strong",{parentName:"p"},"external contract")," can be stored and changed inside the contract storage. This way, users can customize such contracts to implement a specific logic that is changeable at any time."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Multiple Universal Receiver Delegate",src:n(7149).Z,width:"2460",height:"1625"})),(0,r.kt)("p",null,"If the contract implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"universalReceiver(..)")," supports ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"https://github.com/ERC725Alliance/erc725/blob/main/docs/ERC-725.md#erc725y"},"ERC725Y Data key-value store")),", the address of the ",(0,r.kt)("strong",{parentName:"p"},"external contract")," MUST be set as a value for the ",(0,r.kt)("strong",{parentName:"p"},"LSP1UniversalReceiverDelegate data key")," shown below to enable the optional extension. This key-value pair will act as a reference, making this external contract upgradeable if required."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "LSP1UniversalReceiverDelegate",\n  "key": "0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47",\n  "keyType": "Singleton",\n  "valueType": "address",\n  "valueContent": "Address"\n}\n')),(0,r.kt)("p",null,"Check ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/standards/generic-standards/lsp2-json-schema"},"LSP2-ERC725YJSONSchema"))," for more information about the JSON schema."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/lukso-network/LIPs/blob/main/LSPs/LSP-1-UniversalReceiver.md"},"LUKSO Standards Proposals: LSP1 - Universal Receiver (Standard Specification, GitHub)"))))}p.isMDXComponent=!0},7149:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/multiple-urd-dbacaac7a9b61d1a1cd209512248dcb7.jpeg"},7018:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/on-received-functions-371eabf6dce3b5864aeacd9a4f587d2f.jpeg"},2164:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/token-contract-registry-7b488bd548f204eb746c68fb87b6bf52.jpeg"},7543:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/unified-notification-function-4623138f98fce2e4eed11af920e00ab2.jpeg"},4709:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/universal-receiver-delegate-a2cb96f1665b4bb8cd1bb5d0071c1eb8.jpeg"},5797:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/universal-receiver-event-92438c1b58104b1b40ef658e1eec5316.jpeg"},2807:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/universal-receiver-logic-3c42adedb2b44c6fc6a95003f01439fa.jpeg"}}]);